{
  "__type__": "cc.EffectAsset",
  "_name": "surfaces/standard",
  "_objFlags": 0,
  "_native": "",
  "techniques": [
    {
      "name": "opaque",
      "passes": [
        {
          "program": "surfaces/standard|standard-vs|standard-fs",
          "properties": {
            "tilingOffset": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            },
            "mainColor": {
              "value": [
                1,
                1,
                1,
                1
              ],
              "linear": true,
              "editor": {
                "displayName": "Albedo",
                "type": "color"
              },
              "type": 16,
              "handleInfo": [
                "albedo",
                0,
                16
              ]
            },
            "albedoScale": {
              "value": [
                1,
                1,
                1
              ],
              "type": 15,
              "handleInfo": [
                "albedoScaleAndCutoff",
                0,
                15
              ]
            },
            "alphaThreshold": {
              "value": [
                0.5
              ],
              "editor": {
                "parent": "USE_ALPHA_TEST",
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.001
              },
              "type": 13,
              "handleInfo": [
                "albedoScaleAndCutoff",
                3,
                13
              ]
            },
            "occlusion": {
              "value": [
                1
              ],
              "editor": {
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.001
              },
              "type": 13,
              "handleInfo": [
                "pbrParams",
                0,
                13
              ]
            },
            "roughness": {
              "value": [
                0.8
              ],
              "editor": {
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.001
              },
              "type": 13,
              "handleInfo": [
                "pbrParams",
                1,
                13
              ]
            },
            "metallic": {
              "value": [
                0.6
              ],
              "editor": {
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.001
              },
              "type": 13,
              "handleInfo": [
                "pbrParams",
                2,
                13
              ]
            },
            "specularIntensity": {
              "value": [
                0.5
              ],
              "editor": {
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.001
              },
              "type": 13,
              "handleInfo": [
                "pbrParams",
                3,
                13
              ]
            },
            "emissive": {
              "value": [
                0,
                0,
                0,
                1
              ],
              "linear": true,
              "editor": {
                "type": "color"
              },
              "type": 16
            },
            "emissiveScale": {
              "value": [
                1,
                1,
                1
              ],
              "type": 15,
              "handleInfo": [
                "emissiveScaleParam",
                0,
                15
              ]
            },
            "normalStrength": {
              "value": [
                1
              ],
              "editor": {
                "parent": "USE_NORMAL_MAP",
                "slide": true,
                "range": [
                  0,
                  5
                ],
                "step": 0.001
              },
              "type": 13,
              "handleInfo": [
                "emissiveScaleParam",
                3,
                13
              ]
            },
            "anisotropyIntensity": {
              "value": [
                1
              ],
              "editor": {
                "parent": "IS_ANISOTROPY",
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.0001
              },
              "type": 13,
              "handleInfo": [
                "anisotropyParam",
                0,
                13
              ]
            },
            "anisotropyRotation": {
              "value": [
                0
              ],
              "editor": {
                "parent": "IS_ANISOTROPY",
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.0001
              },
              "type": 13,
              "handleInfo": [
                "anisotropyParam",
                1,
                13
              ]
            },
            "anisotropyMapResolutionHeight": {
              "value": [
                0
              ],
              "editor": {
                "parent": "FIX_ANISOTROPIC_ROTATION_MAP"
              },
              "type": 13,
              "handleInfo": [
                "anisotropyParam",
                3,
                13
              ]
            },
            "mainTexture": {
              "value": "grey",
              "editor": {
                "displayName": "AlbedoMap"
              },
              "type": 28,
              "handleInfo": [
                "albedoMap",
                0,
                28
              ]
            },
            "normalMap": {
              "value": "normal",
              "type": 28
            },
            "pbrMap": {
              "value": "grey",
              "type": 28
            },
            "occlusionMap": {
              "value": "white",
              "type": 28
            },
            "emissiveMap": {
              "value": "grey",
              "type": 28
            },
            "anisotropyMap": {
              "value": "black",
              "editor": {
                "parent": "IS_ANISOTROPY"
              },
              "type": 28
            },
            "anisotropyMapNearestFilter": {
              "value": "black",
              "editor": {
                "parent": "FIX_ANISOTROPIC_ROTATION_MAP"
              },
              "type": 28
            },
            "albedo": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                1,
                1,
                1
              ]
            },
            "albedoScaleAndCutoff": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                1,
                1,
                0.5
              ]
            },
            "pbrParams": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                0.8,
                0.6,
                0.5
              ]
            },
            "emissiveScaleParam": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                1,
                1,
                1
              ]
            },
            "anisotropyParam": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                0,
                0,
                0
              ]
            },
            "albedoMap": {
              "type": 28,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": "grey"
            }
          }
        },
        {
          "phase": "forward-add",
          "propertyIndex": 0,
          "embeddedMacros": {
            "CC_FORWARD_ADD": true
          },
          "blendState": {
            "targets": [
              {
                "blend": true,
                "blendSrc": 1,
                "blendDst": 1,
                "blendSrcAlpha": 0,
                "blendDstAlpha": 1
              }
            ]
          },
          "program": "surfaces/standard|standard-vs|standard-fs",
          "depthStencilState": {
            "depthFunc": 2,
            "depthTest": true,
            "depthWrite": false
          }
        },
        {
          "phase": "shadow-caster",
          "propertyIndex": 0,
          "rasterizerState": {
            "cullMode": 1
          },
          "program": "surfaces/standard|shadow-caster-vs|shadow-caster-fs",
          "properties": {
            "tilingOffset": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            },
            "mainColor": {
              "value": [
                1,
                1,
                1,
                1
              ],
              "editor": {
                "displayName": "Albedo",
                "type": "color"
              },
              "type": 16,
              "handleInfo": [
                "albedo",
                0,
                16
              ]
            },
            "albedoScale": {
              "value": [
                1,
                1,
                1
              ],
              "type": 15,
              "handleInfo": [
                "albedoScaleAndCutoff",
                0,
                15
              ]
            },
            "alphaThreshold": {
              "value": [
                0.5
              ],
              "editor": {
                "parent": "USE_ALPHA_TEST"
              },
              "type": 13,
              "handleInfo": [
                "albedoScaleAndCutoff",
                3,
                13
              ]
            },
            "mainTexture": {
              "value": "grey",
              "editor": {
                "displayName": "AlbedoMap"
              },
              "type": 28,
              "handleInfo": [
                "albedoMap",
                0,
                28
              ]
            },
            "albedo": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                1,
                1,
                1
              ]
            },
            "albedoScaleAndCutoff": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                1,
                1,
                0.5
              ]
            },
            "albedoMap": {
              "type": 28,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": "grey"
            }
          }
        }
      ]
    },
    {
      "name": "transparent",
      "passes": [
        {
          "embeddedMacros": {
            "CC_FORCE_FORWARD_SHADING": true
          },
          "blendState": {
            "targets": [
              {
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }
            ]
          },
          "program": "surfaces/standard|standard-vs|standard-fs",
          "depthStencilState": {
            "depthTest": true,
            "depthWrite": false
          },
          "properties": {
            "tilingOffset": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            },
            "mainColor": {
              "value": [
                1,
                1,
                1,
                1
              ],
              "linear": true,
              "editor": {
                "displayName": "Albedo",
                "type": "color"
              },
              "type": 16,
              "handleInfo": [
                "albedo",
                0,
                16
              ]
            },
            "albedoScale": {
              "value": [
                1,
                1,
                1
              ],
              "type": 15,
              "handleInfo": [
                "albedoScaleAndCutoff",
                0,
                15
              ]
            },
            "alphaThreshold": {
              "value": [
                0.5
              ],
              "editor": {
                "parent": "USE_ALPHA_TEST",
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.001
              },
              "type": 13,
              "handleInfo": [
                "albedoScaleAndCutoff",
                3,
                13
              ]
            },
            "occlusion": {
              "value": [
                1
              ],
              "editor": {
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.001
              },
              "type": 13,
              "handleInfo": [
                "pbrParams",
                0,
                13
              ]
            },
            "roughness": {
              "value": [
                0.8
              ],
              "editor": {
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.001
              },
              "type": 13,
              "handleInfo": [
                "pbrParams",
                1,
                13
              ]
            },
            "metallic": {
              "value": [
                0.6
              ],
              "editor": {
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.001
              },
              "type": 13,
              "handleInfo": [
                "pbrParams",
                2,
                13
              ]
            },
            "specularIntensity": {
              "value": [
                0.5
              ],
              "editor": {
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.001
              },
              "type": 13,
              "handleInfo": [
                "pbrParams",
                3,
                13
              ]
            },
            "emissive": {
              "value": [
                0,
                0,
                0,
                1
              ],
              "linear": true,
              "editor": {
                "type": "color"
              },
              "type": 16
            },
            "emissiveScale": {
              "value": [
                1,
                1,
                1
              ],
              "type": 15,
              "handleInfo": [
                "emissiveScaleParam",
                0,
                15
              ]
            },
            "normalStrength": {
              "value": [
                1
              ],
              "editor": {
                "parent": "USE_NORMAL_MAP",
                "slide": true,
                "range": [
                  0,
                  5
                ],
                "step": 0.001
              },
              "type": 13,
              "handleInfo": [
                "emissiveScaleParam",
                3,
                13
              ]
            },
            "anisotropyIntensity": {
              "value": [
                1
              ],
              "editor": {
                "parent": "IS_ANISOTROPY",
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.0001
              },
              "type": 13,
              "handleInfo": [
                "anisotropyParam",
                0,
                13
              ]
            },
            "anisotropyRotation": {
              "value": [
                0
              ],
              "editor": {
                "parent": "IS_ANISOTROPY",
                "slide": true,
                "range": [
                  0,
                  1
                ],
                "step": 0.0001
              },
              "type": 13,
              "handleInfo": [
                "anisotropyParam",
                1,
                13
              ]
            },
            "anisotropyMapResolutionHeight": {
              "value": [
                0
              ],
              "editor": {
                "parent": "FIX_ANISOTROPIC_ROTATION_MAP"
              },
              "type": 13,
              "handleInfo": [
                "anisotropyParam",
                3,
                13
              ]
            },
            "mainTexture": {
              "value": "grey",
              "editor": {
                "displayName": "AlbedoMap"
              },
              "type": 28,
              "handleInfo": [
                "albedoMap",
                0,
                28
              ]
            },
            "normalMap": {
              "value": "normal",
              "type": 28
            },
            "pbrMap": {
              "value": "grey",
              "type": 28
            },
            "occlusionMap": {
              "value": "white",
              "type": 28
            },
            "emissiveMap": {
              "value": "grey",
              "type": 28
            },
            "anisotropyMap": {
              "value": "black",
              "editor": {
                "parent": "IS_ANISOTROPY"
              },
              "type": 28
            },
            "anisotropyMapNearestFilter": {
              "value": "black",
              "editor": {
                "parent": "FIX_ANISOTROPIC_ROTATION_MAP"
              },
              "type": 28
            },
            "albedo": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                1,
                1,
                1
              ]
            },
            "albedoScaleAndCutoff": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                1,
                1,
                0.5
              ]
            },
            "pbrParams": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                0.8,
                0.6,
                0.5
              ]
            },
            "emissiveScaleParam": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                1,
                1,
                1
              ]
            },
            "anisotropyParam": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                0,
                0,
                0
              ]
            },
            "albedoMap": {
              "type": 28,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": "grey"
            }
          }
        },
        {
          "phase": "forward-add",
          "propertyIndex": 0,
          "embeddedMacros": {
            "CC_FORWARD_ADD": true
          },
          "blendState": {
            "targets": [
              {
                "blend": true,
                "blendSrc": 1,
                "blendDst": 1,
                "blendSrcAlpha": 0,
                "blendDstAlpha": 1
              }
            ]
          },
          "program": "surfaces/standard|standard-vs|standard-fs",
          "depthStencilState": {
            "depthFunc": 2,
            "depthTest": true,
            "depthWrite": false
          }
        },
        {
          "phase": "shadow-caster",
          "propertyIndex": 0,
          "rasterizerState": {
            "cullMode": 1
          },
          "program": "surfaces/standard|shadow-caster-vs|shadow-caster-fs",
          "properties": {
            "tilingOffset": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            },
            "mainColor": {
              "value": [
                1,
                1,
                1,
                1
              ],
              "editor": {
                "displayName": "Albedo",
                "type": "color"
              },
              "type": 16,
              "handleInfo": [
                "albedo",
                0,
                16
              ]
            },
            "albedoScale": {
              "value": [
                1,
                1,
                1
              ],
              "type": 15,
              "handleInfo": [
                "albedoScaleAndCutoff",
                0,
                15
              ]
            },
            "alphaThreshold": {
              "value": [
                0.5
              ],
              "editor": {
                "parent": "USE_ALPHA_TEST"
              },
              "type": 13,
              "handleInfo": [
                "albedoScaleAndCutoff",
                3,
                13
              ]
            },
            "mainTexture": {
              "value": "grey",
              "editor": {
                "displayName": "AlbedoMap"
              },
              "type": 28,
              "handleInfo": [
                "albedoMap",
                0,
                28
              ]
            },
            "albedo": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                1,
                1,
                1
              ]
            },
            "albedoScaleAndCutoff": {
              "type": 16,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": [
                1,
                1,
                1,
                0.5
              ]
            },
            "albedoMap": {
              "type": 28,
              "editor": {
                "visible": false,
                "deprecated": true
              },
              "value": "grey"
            }
          }
        }
      ]
    }
  ],
  "shaders": [
    {
      "blocks": [
        {
          "name": "Constants",
          "members": [
            {
              "name": "tilingOffset",
              "type": 16,
              "count": 1
            },
            {
              "name": "albedo",
              "type": 16,
              "count": 1
            },
            {
              "name": "albedoScaleAndCutoff",
              "type": 16,
              "count": 1
            },
            {
              "name": "pbrParams",
              "type": 16,
              "count": 1
            },
            {
              "name": "emissive",
              "type": 16,
              "count": 1
            },
            {
              "name": "emissiveScaleParam",
              "type": 16,
              "count": 1
            },
            {
              "name": "anisotropyParam",
              "type": 16,
              "count": 1
            }
          ],
          "defines": [],
          "stageFlags": 17,
          "binding": 0
        }
      ],
      "samplerTextures": [
        {
          "name": "albedoMap",
          "type": 28,
          "count": 1,
          "defines": [
            "USE_ALBEDO_MAP"
          ],
          "stageFlags": 16,
          "binding": 1
        },
        {
          "name": "normalMap",
          "type": 28,
          "count": 1,
          "defines": [
            "USE_NORMAL_MAP"
          ],
          "stageFlags": 16,
          "binding": 2
        },
        {
          "name": "pbrMap",
          "type": 28,
          "count": 1,
          "defines": [
            "USE_PBR_MAP"
          ],
          "stageFlags": 16,
          "binding": 3
        },
        {
          "name": "occlusionMap",
          "type": 28,
          "count": 1,
          "defines": [
            "USE_OCCLUSION_MAP"
          ],
          "stageFlags": 16,
          "binding": 4
        },
        {
          "name": "emissiveMap",
          "type": 28,
          "count": 1,
          "defines": [
            "USE_EMISSIVE_MAP"
          ],
          "stageFlags": 16,
          "binding": 5
        },
        {
          "name": "anisotropyMap",
          "type": 28,
          "count": 1,
          "defines": [
            "IS_ANISOTROPY",
            "USE_ANISOTROPY_MAP"
          ],
          "stageFlags": 16,
          "binding": 6
        },
        {
          "name": "anisotropyMapNearestFilter",
          "type": 28,
          "count": 1,
          "defines": [
            "IS_ANISOTROPY",
            "USE_ANISOTROPY_MAP"
          ],
          "stageFlags": 16,
          "binding": 7
        }
      ],
      "samplers": [],
      "textures": [],
      "buffers": [],
      "images": [],
      "subpassInputs": [],
      "attributes": [
        {
          "name": "a_position",
          "defines": [],
          "format": 32,
          "location": 0
        },
        {
          "name": "a_normal",
          "defines": [],
          "format": 32,
          "location": 1
        },
        {
          "name": "a_texCoord",
          "defines": [],
          "format": 21,
          "location": 2
        },
        {
          "name": "a_tangent",
          "defines": [],
          "format": 44,
          "location": 3
        },
        {
          "name": "a_color",
          "defines": [
            "CC_SURFACES_USE_VERTEX_COLOR"
          ],
          "format": 44,
          "location": 6
        },
        {
          "name": "a_texCoord1",
          "defines": [],
          "format": 21,
          "location": 7
        },
        {
          "name": "a_joints",
          "defines": [
            "CC_USE_SKINNING"
          ],
          "location": 4
        },
        {
          "name": "a_weights",
          "defines": [
            "CC_USE_SKINNING"
          ],
          "format": 44,
          "location": 5
        },
        {
          "name": "a_jointAnimInfo",
          "defines": [
            "USE_INSTANCING",
            "CC_USE_BAKED_ANIMATION"
          ],
          "format": 44,
          "isInstanced": true,
          "location": 8
        },
        {
          "name": "a_matWorld0",
          "defines": [
            "USE_INSTANCING"
          ],
          "format": 44,
          "isInstanced": true,
          "location": 9
        },
        {
          "name": "a_matWorld1",
          "defines": [
            "USE_INSTANCING"
          ],
          "format": 44,
          "isInstanced": true,
          "location": 10
        },
        {
          "name": "a_matWorld2",
          "defines": [
            "USE_INSTANCING"
          ],
          "format": 44,
          "isInstanced": true,
          "location": 11
        },
        {
          "name": "a_lightingMapUVParam",
          "defines": [
            "USE_INSTANCING",
            "CC_USE_LIGHTMAP"
          ],
          "format": 44,
          "isInstanced": true,
          "location": 12
        },
        {
          "name": "a_localShadowBias",
          "defines": [
            "USE_INSTANCING",
            "CC_RECEIVE_SHADOW"
          ],
          "format": 21,
          "isInstanced": true,
          "location": 13
        },
        {
          "name": "a_dyn_batch_id",
          "defines": [
            "!USE_INSTANCING",
            "USE_BATCHING"
          ],
          "format": 11,
          "location": 14
        },
        {
          "name": "a_vertexId",
          "defines": [
            "CC_USE_MORPH"
          ],
          "format": 11,
          "location": 15
        }
      ],
      "varyings": [
        {
          "name": "v_worldPos",
          "type": 15,
          "count": 1,
          "defines": [],
          "stageFlags": 17,
          "location": 0
        },
        {
          "name": "v_normal",
          "type": 16,
          "count": 1,
          "defines": [],
          "stageFlags": 17,
          "location": 1
        },
        {
          "name": "v_uv",
          "type": 14,
          "count": 1,
          "defines": [],
          "stageFlags": 17,
          "location": 2
        },
        {
          "name": "v_color",
          "type": 16,
          "count": 1,
          "defines": [
            "CC_SURFACES_USE_VERTEX_COLOR"
          ],
          "stageFlags": 17,
          "location": 3
        },
        {
          "name": "v_tangent",
          "type": 16,
          "count": 1,
          "defines": [],
          "stageFlags": 17,
          "location": 4
        },
        {
          "name": "v_uv1",
          "type": 14,
          "count": 1,
          "defines": [
            "!CC_USE_LIGHTMAP"
          ],
          "stageFlags": 17,
          "location": 5
        },
        {
          "name": "v_luv",
          "type": 15,
          "count": 1,
          "defines": [
            "CC_USE_LIGHTMAP",
            "!USE_BATCHING",
            "!CC_FORWARD_ADD"
          ],
          "stageFlags": 17,
          "location": 6
        },
        {
          "name": "v_shadowBias",
          "type": 14,
          "count": 1,
          "defines": [
            "CC_RECEIVE_SHADOW"
          ],
          "stageFlags": 17,
          "location": 7
        },
        {
          "name": "v_fogFactor",
          "type": 13,
          "count": 1,
          "defines": [
            "CC_USE_FOG",
            "!CC_USE_ACCURATE_FOG"
          ],
          "stageFlags": 17,
          "location": 8
        },
        {
          "name": "v_localPos",
          "type": 16,
          "count": 1,
          "defines": [],
          "stageFlags": 17,
          "location": 9
        }
      ],
      "fragColors": [
        {
          "tags": [],
          "name": "fragColorX",
          "typename": "vec4",
          "type": 16,
          "count": 1,
          "defines": [],
          "stageFlags": 16,
          "location": 0
        },
        {
          "tags": [
            "CC_PIPELINE_TYPE"
          ],
          "name": "fragColor0",
          "typename": "vec4",
          "type": 16,
          "count": 1,
          "defines": [
            "CC_PIPELINE_TYPE"
          ],
          "stageFlags": 16,
          "location": 1
        },
        {
          "name": "fragColor1",
          "typename": "vec4",
          "type": 16,
          "count": 1,
          "defines": [
            "CC_PIPELINE_TYPE"
          ],
          "stageFlags": 16,
          "location": 2
        },
        {
          "name": "fragColor2",
          "typename": "vec4",
          "type": 16,
          "count": 1,
          "defines": [
            "CC_PIPELINE_TYPE"
          ],
          "stageFlags": 16,
          "location": 3
        }
      ],
      "hash": 2155669275,
      "glsl4": {
        "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#if CC_USE_LIGHTMAP\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 1\n  #endif\n#else\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  layout(location = 3) in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  layout(location = 6) in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 7) in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 8) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 9) in vec4 a_matWorld0;\n  layout(location = 10) in vec4 a_matWorld1;\n  layout(location = 11) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 12) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 13) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 14) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n#endif\nlayout(location = 0) out highp vec3 v_worldPos;\nlayout(location = 1) out mediump vec4 v_normal;\nlayout(location = 2) out vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  layout(location = 3) out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  layout(location = 4) out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  layout(location = 5) out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 6) out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) out mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  layout(location = 8) out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  layout(location = 9) out highp vec4 v_localPos;\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW\n  vec2 shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      layout(set = 2, binding = 6) uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(set = 2, binding = 3) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1;\n#endif\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBias;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW\n    In.shadowBias = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBias += a_localShadowBias.xy;\n    #elif !USE_BATCHING\n      In.shadowBias += cc_localShadowBias.xy;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferShadow(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexOutput(In);\n}",
        "frag": "\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#if CC_USE_LIGHTMAP\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 1\n  #endif\n#else\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nlayout(location = 0) in highp vec3 v_worldPos;\nlayout(location = 1) in mediump vec4 v_normal;\nlayout(location = 2) in vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  layout(location = 3) in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  layout(location = 4) in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  layout(location = 5) in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 6) in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) in mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  layout(location = 8) in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  layout(location = 9) in highp vec4 v_localPos;\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (cc_debug_view_mode.y > 0.0)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (cc_debug_view_mode.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (cc_debug_view_composite_pack_1.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (cc_debug_view_composite_pack_1.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (cc_debug_view_composite_pack_1.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (cc_debug_view_composite_pack_1.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (cc_debug_view_composite_pack_2.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (cc_debug_view_composite_pack_2.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (cc_debug_view_composite_pack_2.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (cc_debug_view_composite_pack_2.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (cc_debug_view_composite_pack_3.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (cc_debug_view_composite_pack_3.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (cc_debug_view_composite_pack_3.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (cc_debug_view_composite_pack_3.w > 0.0)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(set = 2, binding = 1) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(set = 0, binding = 3) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 5) uniform samplerCube cc_environment;\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 7) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal.xyz, tangent) * mirrorNormal;\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(vec3 R, float roughness, float mipCount) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 envmap = fragTextureLod(cc_environment, rotationDir, roughness * (mipCount - 1.0));\n      #if CC_USE_IBL == 2\n        return unpackRGBE(envmap);\n      #else\n        return SRGBToLinear(envmap.rgb);\n      #endif\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 4) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 6) uniform highp sampler2D cc_spotShadowMap;\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    if (pcf > 2.9) {\n      return CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      return CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      int layer = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= (0.0 + layerThreshold) && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= (0.0 + layerThreshold) && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && layer < 0) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          layer = i;\n        }\n      }\n      return layer;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      vec4 csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n      vec4 shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(shadowPos, N, shadowBias);\n    }\n  #endif\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n  vec4 GetLightMapColor(sampler2D lightingMap, vec2 luv, float lum)\n  {\n      vec4 lightmap = texture(lightingMap, luv);\n      lightmap.rgb *= lum;\n  #if CC_USE_HDR\n      lightmap.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n      return lightmap;\n  }\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 4) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 5) uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  layout(set = 1, binding = 6) uniform sampler2D anisotropyMap;\n  layout(set = 1, binding = 7) uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n    baseColor.a *= FSInput_vertexColor.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  baseColor.rgb *= albedoScaleAndCutoff.xyz;\n  return baseColor;\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, emissiveScaleParam.w, normal.xyz, FSInput_worldTangent, FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n  float anisotropyRotation = anisotropyParam.y * PI;\n  float anisotropyShape = anisotropyParam.x;\n  #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n    vec4 tex = texture(anisotropyMap, DEFAULT_UV);\n    anisotropyRotation = fract(anisotropyRotation * 0.5 + tex.y) * PI2;\n    anisotropyShape *= tex.x;\n  #endif\n  #if FIX_ANISOTROPIC_ROTATION_MAP\n    #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n      vec4 reference = texture(anisotropyMapNearestFilter, DEFAULT_UV);\n      vec2 oneTap = vec2(0.0, 1.0 / anisotropyParam.w);\n      float threshold = 0.2;\n      vec4 sample1 = texture(anisotropyMapNearestFilter, DEFAULT_UV + oneTap);\n      vec4 sample2 = texture(anisotropyMapNearestFilter, DEFAULT_UV - oneTap);\n      if (abs(sample1.y - reference.y) > threshold || abs(sample2.y - reference.y) > threshold) {\n          tex.y = reference.y;\n      }\n      anisotropyRotation = fract(anisotropyParam.y * PI * 0.5 + tex.y) * PI2;\n    #endif\n  #endif\n  isRotation = 1.0;\n  return vec4(anisotropyShape, anisotropyRotation, 0.0, 0.0);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n  return emissive;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, DEFAULT_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, DEFAULT_UV).r;\n  #endif\n  return pbr;\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  vec3 T, B;\n  float specularParam;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = clamp(r1, 0.0, 1.0);\n    roughnessY = clamp(r2, 0.0, 1.0);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange)\n{\n  float litRadiusSqr = lightRadius * lightRadius;\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float edgeAttenuation = litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n  return NoL > 0.0;\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    lightingDiffuse = irradiance * DiffuseCoefficient_EnergyConservation;\n    float roughness = lightingData.specularParam;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    float rT, rB;\n    GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n    float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n#else\n  #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n    float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n  #else\n    float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n  #endif\n#endif\n    lightingSpecular = irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = clamp(dot(N, H), 0.0, 1.0);\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvoid CCSurfacesLightingCalculateEnvironment(inout LightingResult lightingResult, in LightingIntermediateData lightingData)\n{\n  float roughness = lightingData.specularParam;\n  float fAmb = 0.5 - lightingData.N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  vec3 envSpec = vec3(0.0);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, lightingData.N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = reflect(-lightingData.V, lightingData.N);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(R, roughness, cc_ambientGround.w, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, cc_ambientGround.w, 0.6);\n      #else\n        envSpec = EnvReflection(R, roughness, cc_ambientGround.w);\n      #endif\n    #endif\n  #endif\n  lightingResult.environmentDiffuse = ambDiff.rgb * cc_ambientSky.w;\n  lightingResult.environmentSpecular = envSpec * cc_ambientSky.w;\n}\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n};\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = FSInput_worldTangent;\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = FSInput_worldNormal;\n      surfaceData.worldTangent = FSInput_worldTangent;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n      surfaceData.baseColor.rgb = vec3(1.0);\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = IntegratedGFApprox(CCSurfacesGetSpecularColor(surfaceData).xyz, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutput0(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutput1(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutput2(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n  color.xyz += lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n#else\n  color.xyz +=\n    ( lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting\n    + lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithLighting)\n    * lightingResult.shadow;\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting)\n    * lightingResult.ao;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nvoid CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) < EPSILON))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) < EPSILON)) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) < EPSILON))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) < EPSILON))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) < EPSILON))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) < EPSILON)) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_METALLIC)) < EPSILON)) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) < EPSILON)) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD && !CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, cc_lightPos[i].xyz - worldPos);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            vec4 shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPos, worldPos, shadowBias);\n          }\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW) {\n          shadow = 1.0;\n        }\n      #endif\n        float distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i]);\n        float angleAtt = 1.0;\n        if (cc_lightPos[i].w > 0.0) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt * shadow;\n        lightingResult.directDiffuse += diffuseLighting * multiplier;\n        lightingResult.directSpecular += specularLighting * multiplier;\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            if (cc_shadowLPNNInfo.w > 0.0) {\n              #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n                lightingResult.shadow = CCCSMFactorBase(surfaceData.worldPos, lightingData.N, shadowBias);\n              #endif\n            } else {\n              #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n                vec4 shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n                lightingResult.shadow = CCShadowFactorBase(shadowPos, lightingData.N, shadowBias);\n              #endif\n            }\n          }\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !USE_BATCHING && !CC_FORWARD_ADD\n        vec4 lightmap = GetLightMapColor(cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z);\n        lightingResult.lightmapColor = lightmap.rgb;\n        lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #else\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult, lightingData);\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n      #endif\n    }\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) < EPSILON))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) < EPSILON))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV0)) < EPSILON))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV1)) < EPSILON))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) < EPSILON))\n    {\n      #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) < EPSILON))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) < EPSILON))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) < EPSILON))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n      bool isDebugMatched = false;\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) < EPSILON))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) < EPSILON))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) < EPSILON))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) < EPSILON))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) < EPSILON))\n    {\n        color.rgb = lightingResult.emissive;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_AO)) < EPSILON))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SHADOW)) < EPSILON))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isDebugMatched = true;\n    }\n    return isDebugMatched;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    #if !CC_FORWARD_ADD\n      float fogFactor = 1.0;\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      #if !CC_FORWARD_ADD\n        CCSurfacesDebugViewMeshData(debugColor);\n        CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n        if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FOG)) < EPSILON))\n        {\n          fogFactor = 1.0 - fogFactor;\n          debugColor = vec4(fogFactor, fogFactor, fogFactor, 1.0);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON) || (abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON) || (abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              #if CC_USE_HDR\n                if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n                    debugColor.rgb = ACESToneMap(debugColor.rgb);\n              #endif\n              if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n                  debugColor.rgb = LinearToSRGB(debugColor.rgb);\n            }\n        }\n      fragColorX = debugColor;\n      return;\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_HDR\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n      #endif\n        color.rgb = ACESToneMap(color.rgb);\n    #endif\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n    #if !CC_FORWARD_ADD && CC_USE_FOG != 4\n      CC_APPLY_FOG_BASE(color, fogFactor);\n    #endif\n    fragColorX = CCSurfacesDebugDisplayInvalidNumber(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n    layout(location = 0) out vec4 fragColor0;\n    layout(location = 1) out vec4 fragColor1;\n    layout(location = 2) out vec4 fragColor2;\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      fragColor0 = CCSurfacesDeferredOutput0(surfaceData);\n      fragColor1 = CCSurfacesDeferredOutput1(surfaceData);\n      fragColor2 = CCSurfacesDeferredOutput2(surfaceData);\n    }\n#endif"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#if CC_USE_LIGHTMAP\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 1\n  #endif\n#else\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\nout highp vec3 v_worldPos;\nout mediump vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW\n  vec2 shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1;\n#endif\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBias;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW\n    In.shadowBias = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBias += a_localShadowBias.xy;\n    #elif !USE_BATCHING\n      In.shadowBias += cc_localShadowBias.xy;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferShadow(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexOutput(In);\n}",
        "frag": "\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#if CC_USE_LIGHTMAP\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 1\n  #endif\n#else\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin highp vec3 v_worldPos;\nin mediump vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (cc_debug_view_mode.y > 0.0)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (cc_debug_view_mode.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (cc_debug_view_composite_pack_1.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (cc_debug_view_composite_pack_1.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (cc_debug_view_composite_pack_1.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (cc_debug_view_composite_pack_1.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (cc_debug_view_composite_pack_2.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (cc_debug_view_composite_pack_2.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (cc_debug_view_composite_pack_2.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (cc_debug_view_composite_pack_2.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (cc_debug_view_composite_pack_3.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (cc_debug_view_composite_pack_3.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (cc_debug_view_composite_pack_3.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (cc_debug_view_composite_pack_3.w > 0.0)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal.xyz, tangent) * mirrorNormal;\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(vec3 R, float roughness, float mipCount) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 envmap = fragTextureLod(cc_environment, rotationDir, roughness * (mipCount - 1.0));\n      #if CC_USE_IBL == 2\n        return unpackRGBE(envmap);\n      #else\n        return SRGBToLinear(envmap.rgb);\n      #endif\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    if (pcf > 2.9) {\n      return CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      return CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      int layer = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= (0.0 + layerThreshold) && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= (0.0 + layerThreshold) && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && layer < 0) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          layer = i;\n        }\n      }\n      return layer;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      vec4 csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n      vec4 shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(shadowPos, N, shadowBias);\n    }\n  #endif\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  vec4 GetLightMapColor(sampler2D lightingMap, vec2 luv, float lum)\n  {\n      vec4 lightmap = texture(lightingMap, luv);\n      lightmap.rgb *= lum;\n  #if CC_USE_HDR\n      lightmap.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n      return lightmap;\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n    baseColor.a *= FSInput_vertexColor.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  baseColor.rgb *= albedoScaleAndCutoff.xyz;\n  return baseColor;\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, emissiveScaleParam.w, normal.xyz, FSInput_worldTangent, FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n  float anisotropyRotation = anisotropyParam.y * PI;\n  float anisotropyShape = anisotropyParam.x;\n  #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n    vec4 tex = texture(anisotropyMap, DEFAULT_UV);\n    anisotropyRotation = fract(anisotropyRotation * 0.5 + tex.y) * PI2;\n    anisotropyShape *= tex.x;\n  #endif\n  #if FIX_ANISOTROPIC_ROTATION_MAP\n    #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n      vec4 reference = texture(anisotropyMapNearestFilter, DEFAULT_UV);\n      vec2 oneTap = vec2(0.0, 1.0 / anisotropyParam.w);\n      float threshold = 0.2;\n      vec4 sample1 = texture(anisotropyMapNearestFilter, DEFAULT_UV + oneTap);\n      vec4 sample2 = texture(anisotropyMapNearestFilter, DEFAULT_UV - oneTap);\n      if (abs(sample1.y - reference.y) > threshold || abs(sample2.y - reference.y) > threshold) {\n          tex.y = reference.y;\n      }\n      anisotropyRotation = fract(anisotropyParam.y * PI * 0.5 + tex.y) * PI2;\n    #endif\n  #endif\n  isRotation = 1.0;\n  return vec4(anisotropyShape, anisotropyRotation, 0.0, 0.0);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n  return emissive;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, DEFAULT_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, DEFAULT_UV).r;\n  #endif\n  return pbr;\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  vec3 T, B;\n  float specularParam;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = clamp(r1, 0.0, 1.0);\n    roughnessY = clamp(r2, 0.0, 1.0);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange)\n{\n  float litRadiusSqr = lightRadius * lightRadius;\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float edgeAttenuation = litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n  return NoL > 0.0;\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    lightingDiffuse = irradiance * DiffuseCoefficient_EnergyConservation;\n    float roughness = lightingData.specularParam;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    float rT, rB;\n    GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n    float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n#else\n  #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n    float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n  #else\n    float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n  #endif\n#endif\n    lightingSpecular = irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = clamp(dot(N, H), 0.0, 1.0);\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvoid CCSurfacesLightingCalculateEnvironment(inout LightingResult lightingResult, in LightingIntermediateData lightingData)\n{\n  float roughness = lightingData.specularParam;\n  float fAmb = 0.5 - lightingData.N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  vec3 envSpec = vec3(0.0);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, lightingData.N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = reflect(-lightingData.V, lightingData.N);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(R, roughness, cc_ambientGround.w, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, cc_ambientGround.w, 0.6);\n      #else\n        envSpec = EnvReflection(R, roughness, cc_ambientGround.w);\n      #endif\n    #endif\n  #endif\n  lightingResult.environmentDiffuse = ambDiff.rgb * cc_ambientSky.w;\n  lightingResult.environmentSpecular = envSpec * cc_ambientSky.w;\n}\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n};\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = FSInput_worldTangent;\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = FSInput_worldNormal;\n      surfaceData.worldTangent = FSInput_worldTangent;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n      surfaceData.baseColor.rgb = vec3(1.0);\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = IntegratedGFApprox(CCSurfacesGetSpecularColor(surfaceData).xyz, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutput0(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutput1(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutput2(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n  color.xyz += lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n#else\n  color.xyz +=\n    ( lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting\n    + lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithLighting)\n    * lightingResult.shadow;\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting)\n    * lightingResult.ao;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nvoid CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) < EPSILON))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) < EPSILON)) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) < EPSILON))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) < EPSILON))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) < EPSILON))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) < EPSILON)) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_METALLIC)) < EPSILON)) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) < EPSILON)) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD && !CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, cc_lightPos[i].xyz - worldPos);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            vec4 shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPos, worldPos, shadowBias);\n          }\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW) {\n          shadow = 1.0;\n        }\n      #endif\n        float distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i]);\n        float angleAtt = 1.0;\n        if (cc_lightPos[i].w > 0.0) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt * shadow;\n        lightingResult.directDiffuse += diffuseLighting * multiplier;\n        lightingResult.directSpecular += specularLighting * multiplier;\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            if (cc_shadowLPNNInfo.w > 0.0) {\n              #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n                lightingResult.shadow = CCCSMFactorBase(surfaceData.worldPos, lightingData.N, shadowBias);\n              #endif\n            } else {\n              #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n                vec4 shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n                lightingResult.shadow = CCShadowFactorBase(shadowPos, lightingData.N, shadowBias);\n              #endif\n            }\n          }\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !USE_BATCHING && !CC_FORWARD_ADD\n        vec4 lightmap = GetLightMapColor(cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z);\n        lightingResult.lightmapColor = lightmap.rgb;\n        lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #else\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult, lightingData);\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n      #endif\n    }\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) < EPSILON))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) < EPSILON))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV0)) < EPSILON))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV1)) < EPSILON))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) < EPSILON))\n    {\n      #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) < EPSILON))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) < EPSILON))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) < EPSILON))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n      bool isDebugMatched = false;\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) < EPSILON))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) < EPSILON))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) < EPSILON))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) < EPSILON))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) < EPSILON))\n    {\n        color.rgb = lightingResult.emissive;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_AO)) < EPSILON))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SHADOW)) < EPSILON))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isDebugMatched = true;\n    }\n    return isDebugMatched;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    #if !CC_FORWARD_ADD\n      float fogFactor = 1.0;\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      #if !CC_FORWARD_ADD\n        CCSurfacesDebugViewMeshData(debugColor);\n        CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n        if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FOG)) < EPSILON))\n        {\n          fogFactor = 1.0 - fogFactor;\n          debugColor = vec4(fogFactor, fogFactor, fogFactor, 1.0);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON) || (abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON) || (abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              #if CC_USE_HDR\n                if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n                    debugColor.rgb = ACESToneMap(debugColor.rgb);\n              #endif\n              if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n                  debugColor.rgb = LinearToSRGB(debugColor.rgb);\n            }\n        }\n      fragColorX = debugColor;\n      return;\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_HDR\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n      #endif\n        color.rgb = ACESToneMap(color.rgb);\n    #endif\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n    #if !CC_FORWARD_ADD && CC_USE_FOG != 4\n      CC_APPLY_FOG_BASE(color, fogFactor);\n    #endif\n    fragColorX = CCSurfacesDebugDisplayInvalidNumber(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n    layout(location = 0) out vec4 fragColor0;\n    layout(location = 1) out vec4 fragColor1;\n    layout(location = 2) out vec4 fragColor2;\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      fragColor0 = CCSurfacesDeferredOutput0(surfaceData);\n      fragColor1 = CCSurfacesDeferredOutput1(surfaceData);\n      fragColor2 = CCSurfacesDeferredOutput2(surfaceData);\n    }\n#endif"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#if CC_USE_LIGHTMAP\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 1\n  #endif\n#else\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW\n  vec2 shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1;\n#endif\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBias;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW\n    In.shadowBias = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBias += a_localShadowBias.xy;\n    #elif !USE_BATCHING\n      In.shadowBias += cc_localShadowBias.xy;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferShadow(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexOutput(In);\n}",
        "frag": "\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#if CC_USE_LIGHTMAP\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 1\n  #endif\n#else\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\nuniform highp vec4 cc_time;\n  uniform mediump vec4 cc_debug_view_mode;\n  uniform mediump vec4 cc_debug_view_composite_pack_1;\n  uniform mediump vec4 cc_debug_view_composite_pack_2;\n  uniform mediump vec4 cc_debug_view_composite_pack_3;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (cc_debug_view_mode.y > 0.0)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (cc_debug_view_mode.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (cc_debug_view_composite_pack_1.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (cc_debug_view_composite_pack_1.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (cc_debug_view_composite_pack_1.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (cc_debug_view_composite_pack_1.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (cc_debug_view_composite_pack_2.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (cc_debug_view_composite_pack_2.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (cc_debug_view_composite_pack_2.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (cc_debug_view_composite_pack_2.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (cc_debug_view_composite_pack_3.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (cc_debug_view_composite_pack_3.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (cc_debug_view_composite_pack_3.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (cc_debug_view_composite_pack_3.w > 0.0)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n    #endif\n  #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnan(float val) {\n  return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n}\nbool isinf(float x) {\n  return x == x * 2.0 && x != 0.0;\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal.xyz, tangent) * mirrorNormal;\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(vec3 R, float roughness, float mipCount) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 envmap = fragTextureLod(cc_environment, rotationDir, roughness * (mipCount - 1.0));\n      #if CC_USE_IBL == 2\n        return unpackRGBE(envmap);\n      #else\n        return SRGBToLinear(envmap.rgb);\n      #endif\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    if (pcf > 2.9) {\n      return CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      return CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      int layer = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= (0.0 + layerThreshold) && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= (0.0 + layerThreshold) && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && layer < 0) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          layer = i;\n        }\n      }\n      return layer;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      vec4 csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n      vec4 shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(shadowPos, N, shadowBias);\n    }\n  #endif\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  vec4 GetLightMapColor(sampler2D lightingMap, vec2 luv, float lum)\n  {\n      vec4 lightmap = texture2D(lightingMap, luv);\n      lightmap.rgb *= lum;\n  #if CC_USE_HDR\n      lightmap.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n      return lightmap;\n  }\n#endif\n    uniform vec4 albedo;\n    uniform vec4 albedoScaleAndCutoff;\n    uniform vec4 pbrParams;\n    uniform vec4 emissive;\n    uniform vec4 emissiveScaleParam;\n    uniform vec4 anisotropyParam;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n    baseColor.a *= FSInput_vertexColor.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  baseColor.rgb *= albedoScaleAndCutoff.xyz;\n  return baseColor;\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, emissiveScaleParam.w, normal.xyz, FSInput_worldTangent, FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n  float anisotropyRotation = anisotropyParam.y * PI;\n  float anisotropyShape = anisotropyParam.x;\n  #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n    vec4 tex = texture2D(anisotropyMap, DEFAULT_UV);\n    anisotropyRotation = fract(anisotropyRotation * 0.5 + tex.y) * PI2;\n    anisotropyShape *= tex.x;\n  #endif\n  #if FIX_ANISOTROPIC_ROTATION_MAP\n    #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n      vec4 reference = texture2D(anisotropyMapNearestFilter, DEFAULT_UV);\n      vec2 oneTap = vec2(0.0, 1.0 / anisotropyParam.w);\n      float threshold = 0.2;\n      vec4 sample1 = texture2D(anisotropyMapNearestFilter, DEFAULT_UV + oneTap);\n      vec4 sample2 = texture2D(anisotropyMapNearestFilter, DEFAULT_UV - oneTap);\n      if (abs(sample1.y - reference.y) > threshold || abs(sample2.y - reference.y) > threshold) {\n          tex.y = reference.y;\n      }\n      anisotropyRotation = fract(anisotropyParam.y * PI * 0.5 + tex.y) * PI2;\n    #endif\n  #endif\n  isRotation = 1.0;\n  return vec4(anisotropyShape, anisotropyRotation, 0.0, 0.0);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n  return emissive;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, DEFAULT_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, DEFAULT_UV).r;\n  #endif\n  return pbr;\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  vec3 T, B;\n  float specularParam;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = clamp(r1, 0.0, 1.0);\n    roughnessY = clamp(r2, 0.0, 1.0);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange)\n{\n  float litRadiusSqr = lightRadius * lightRadius;\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float edgeAttenuation = litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n  return NoL > 0.0;\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    lightingDiffuse = irradiance * DiffuseCoefficient_EnergyConservation;\n    float roughness = lightingData.specularParam;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    float rT, rB;\n    GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n    float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n#else\n  #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n    float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n  #else\n    float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n  #endif\n#endif\n    lightingSpecular = irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = clamp(dot(N, H), 0.0, 1.0);\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvoid CCSurfacesLightingCalculateEnvironment(inout LightingResult lightingResult, in LightingIntermediateData lightingData)\n{\n  float roughness = lightingData.specularParam;\n  float fAmb = 0.5 - lightingData.N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  vec3 envSpec = vec3(0.0);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, lightingData.N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = reflect(-lightingData.V, lightingData.N);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(R, roughness, cc_ambientGround.w, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, cc_ambientGround.w, 0.6);\n      #else\n        envSpec = EnvReflection(R, roughness, cc_ambientGround.w);\n      #endif\n    #endif\n  #endif\n  lightingResult.environmentDiffuse = ambDiff.rgb * cc_ambientSky.w;\n  lightingResult.environmentSpecular = envSpec * cc_ambientSky.w;\n}\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n};\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = FSInput_worldTangent;\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = FSInput_worldNormal;\n      surfaceData.worldTangent = FSInput_worldTangent;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n      surfaceData.baseColor.rgb = vec3(1.0);\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = IntegratedGFApprox(CCSurfacesGetSpecularColor(surfaceData).xyz, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutput0(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutput1(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutput2(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n  color.xyz += lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n#else\n  color.xyz +=\n    ( lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting\n    + lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithLighting)\n    * lightingResult.shadow;\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting)\n    * lightingResult.ao;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nvoid CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) < EPSILON))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) < EPSILON)) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) < EPSILON))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) < EPSILON))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) < EPSILON))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) < EPSILON)) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_METALLIC)) < EPSILON)) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) < EPSILON)) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD && !CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, cc_lightPos[i].xyz - worldPos);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            vec4 shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPos, worldPos, shadowBias);\n          }\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW) {\n          shadow = 1.0;\n        }\n      #endif\n        float distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i]);\n        float angleAtt = 1.0;\n        if (cc_lightPos[i].w > 0.0) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt * shadow;\n        lightingResult.directDiffuse += diffuseLighting * multiplier;\n        lightingResult.directSpecular += specularLighting * multiplier;\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            if (cc_shadowLPNNInfo.w > 0.0) {\n              #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n                lightingResult.shadow = CCCSMFactorBase(surfaceData.worldPos, lightingData.N, shadowBias);\n              #endif\n            } else {\n              #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n                vec4 shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n                lightingResult.shadow = CCShadowFactorBase(shadowPos, lightingData.N, shadowBias);\n              #endif\n            }\n          }\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !USE_BATCHING && !CC_FORWARD_ADD\n        vec4 lightmap = GetLightMapColor(cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z);\n        lightingResult.lightmapColor = lightmap.rgb;\n        lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #else\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult, lightingData);\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n      #endif\n    }\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) < EPSILON))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) < EPSILON))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) < EPSILON))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV0)) < EPSILON))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV1)) < EPSILON))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) < EPSILON))\n    {\n      #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) < EPSILON))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) < EPSILON))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) < EPSILON))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n      bool isDebugMatched = false;\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) < EPSILON))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) < EPSILON))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) < EPSILON))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) < EPSILON))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) < EPSILON))\n    {\n        color.rgb = lightingResult.emissive;\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_AO)) < EPSILON))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isDebugMatched = true;\n    }\n    if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SHADOW)) < EPSILON))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isDebugMatched = true;\n    }\n    return isDebugMatched;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    #if !CC_FORWARD_ADD\n      float fogFactor = 1.0;\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      #if !CC_FORWARD_ADD\n        CCSurfacesDebugViewMeshData(debugColor);\n        CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n        if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FOG)) < EPSILON))\n        {\n          fogFactor = 1.0 - fogFactor;\n          debugColor = vec4(fogFactor, fogFactor, fogFactor, 1.0);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON) || (abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON) || (abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              #if CC_USE_HDR\n                if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n                    debugColor.rgb = ACESToneMap(debugColor.rgb);\n              #endif\n              if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n                  debugColor.rgb = LinearToSRGB(debugColor.rgb);\n            }\n        }\n      gl_FragData[0] = debugColor;\n      return;\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_HDR\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n      #endif\n        color.rgb = ACESToneMap(color.rgb);\n    #endif\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n    #if !CC_FORWARD_ADD && CC_USE_FOG != 4\n      CC_APPLY_FOG_BASE(color, fogFactor);\n    #endif\n    gl_FragData[0] = CCSurfacesDebugDisplayInvalidNumber(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      gl_FragData[0] = CCSurfacesDeferredOutput0(surfaceData);\n      gl_FragData[1] = CCSurfacesDeferredOutput1(surfaceData);\n      gl_FragData[2] = CCSurfacesDeferredOutput2(surfaceData);\n    }\n#endif"
      },
      "builtins": {
        "globals": {
          "blocks": [
            {
              "name": "CCGlobal",
              "defines": []
            },
            {
              "name": "CCCamera",
              "defines": []
            },
            {
              "name": "CCShadow",
              "defines": []
            },
            {
              "name": "CCCSM",
              "defines": [
                "CC_SUPPORT_CASCADED_SHADOW_MAP"
              ]
            }
          ],
          "samplerTextures": [
            {
              "name": "cc_environment",
              "defines": [
                "CC_USE_IBL"
              ]
            },
            {
              "name": "cc_diffuseMap",
              "defines": [
                "CC_USE_IBL",
                "CC_USE_DIFFUSEMAP"
              ]
            },
            {
              "name": "cc_shadowMap",
              "defines": [
                "CC_RECEIVE_SHADOW"
              ]
            },
            {
              "name": "cc_spotShadowMap",
              "defines": [
                "CC_RECEIVE_SHADOW"
              ]
            }
          ],
          "buffers": [],
          "images": []
        },
        "locals": {
          "blocks": [
            {
              "name": "CCLocalBatched",
              "defines": [
                "!USE_INSTANCING",
                "USE_BATCHING"
              ]
            },
            {
              "name": "CCLocal",
              "defines": [
                "!USE_INSTANCING",
                "!USE_BATCHING"
              ]
            },
            {
              "name": "CCMorph",
              "defines": [
                "CC_USE_MORPH"
              ]
            },
            {
              "name": "CCSkinningTexture",
              "defines": [
                "CC_USE_SKINNING",
                "CC_USE_BAKED_ANIMATION"
              ]
            },
            {
              "name": "CCSkinningAnimation",
              "defines": [
                "CC_USE_SKINNING",
                "CC_USE_BAKED_ANIMATION"
              ]
            },
            {
              "name": "CCSkinning",
              "defines": [
                "CC_USE_SKINNING",
                "!CC_USE_BAKED_ANIMATION",
                "!CC_USE_REAL_TIME_JOINT_TEXTURE"
              ]
            },
            {
              "name": "CCForwardLight",
              "defines": [
                "CC_FORWARD_ADD",
                "CC_ENABLE_CLUSTERED_LIGHT_CULLING"
              ]
            }
          ],
          "samplerTextures": [
            {
              "name": "cc_PositionDisplacements",
              "defines": [
                "CC_USE_MORPH",
                "CC_MORPH_TARGET_HAS_POSITION"
              ]
            },
            {
              "name": "cc_NormalDisplacements",
              "defines": [
                "CC_USE_MORPH",
                "CC_MORPH_TARGET_HAS_NORMAL"
              ]
            },
            {
              "name": "cc_TangentDisplacements",
              "defines": [
                "CC_USE_MORPH",
                "CC_MORPH_TARGET_HAS_TANGENT"
              ]
            },
            {
              "name": "cc_jointTexture",
              "defines": [
                "CC_USE_SKINNING",
                "CC_USE_BAKED_ANIMATION"
              ]
            },
            {
              "name": "cc_realtimeJoint",
              "defines": [
                "CC_USE_SKINNING",
                "!CC_USE_BAKED_ANIMATION",
                "CC_USE_REAL_TIME_JOINT_TEXTURE"
              ]
            },
            {
              "name": "cc_lightingMap",
              "defines": [
                "CC_USE_LIGHTMAP",
                "!USE_BATCHING",
                "!CC_FORWARD_ADD"
              ]
            }
          ],
          "buffers": [],
          "images": []
        },
        "statistics": {
          "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 135,
          "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 108
        }
      },
      "defines": [
        {
          "name": "HAS_SECOND_UV",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "USE_TWOSIDE",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "IS_ANISOTROPY",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "USE_VERTEX_COLOR",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "USE_INSTANCING",
          "type": "boolean",
          "defines": [],
          "editor": {
            "elevated": true
          }
        },
        {
          "name": "USE_BATCHING",
          "type": "boolean",
          "defines": [
            "!USE_INSTANCING"
          ],
          "editor": {
            "elevated": true
          }
        },
        {
          "name": "CC_USE_LIGHTMAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_SKINNING",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_BAKED_ANIMATION",
          "type": "boolean",
          "defines": [
            "USE_INSTANCING"
          ]
        },
        {
          "name": "CC_RECEIVE_SHADOW",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_MORPH",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_FORWARD_ADD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_FOG",
          "type": "number",
          "defines": [],
          "range": [
            0,
            4
          ]
        },
        {
          "name": "CC_USE_ACCURATE_FOG",
          "type": "boolean",
          "defines": [
            "CC_USE_FOG"
          ]
        },
        {
          "name": "CC_MORPH_TARGET_COUNT",
          "type": "number",
          "defines": [
            "CC_USE_MORPH"
          ],
          "range": [
            2,
            8
          ]
        },
        {
          "name": "CC_MORPH_TARGET_HAS_POSITION",
          "type": "boolean",
          "defines": [
            "CC_USE_MORPH"
          ]
        },
        {
          "name": "CC_MORPH_TARGET_HAS_NORMAL",
          "type": "boolean",
          "defines": [
            "CC_USE_MORPH"
          ]
        },
        {
          "name": "CC_MORPH_TARGET_HAS_TANGENT",
          "type": "boolean",
          "defines": [
            "CC_USE_MORPH"
          ]
        },
        {
          "name": "CC_MORPH_PRECOMPUTED",
          "type": "boolean",
          "defines": [
            "CC_USE_MORPH"
          ]
        },
        {
          "name": "CC_USE_REAL_TIME_JOINT_TEXTURE",
          "type": "boolean",
          "defines": [
            "CC_USE_SKINNING",
            "!CC_USE_BAKED_ANIMATION"
          ]
        },
        {
          "name": "CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER",
          "type": "number",
          "defines": [],
          "range": [
            0,
            1
          ]
        },
        {
          "name": "CC_PIPELINE_TYPE",
          "type": "number",
          "defines": [],
          "range": [
            0,
            1
          ]
        },
        {
          "name": "CC_FORCE_FORWARD_SHADING",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_SUPPORT_CASCADED_SHADOW_MAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_IBL",
          "type": "number",
          "defines": [],
          "range": [
            0,
            2
          ]
        },
        {
          "name": "CC_USE_DIFFUSEMAP",
          "type": "number",
          "defines": [
            "CC_USE_IBL"
          ],
          "range": [
            0,
            2
          ]
        },
        {
          "name": "CC_USE_DEBUG_VIEW",
          "type": "number",
          "defines": [],
          "range": [
            0,
            3
          ]
        },
        {
          "name": "CC_IBL_CONVOLUTED",
          "type": "boolean",
          "defines": [
            "!CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING",
            "CC_USE_IBL"
          ]
        },
        {
          "name": "CC_SHADOWMAP_FORMAT",
          "type": "number",
          "defines": [
            "CC_RECEIVE_SHADOW"
          ],
          "range": [
            0,
            3
          ]
        },
        {
          "name": "CC_SHADOWMAP_USE_LINEAR_DEPTH",
          "type": "boolean",
          "defines": [
            "CC_RECEIVE_SHADOW"
          ]
        },
        {
          "name": "CC_DIR_SHADOW_PCF_TYPE",
          "type": "number",
          "defines": [
            "CC_RECEIVE_SHADOW"
          ],
          "range": [
            0,
            3
          ]
        },
        {
          "name": "CC_USE_HDR",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "USE_ALBEDO_MAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "ALBEDO_UV",
          "type": "string",
          "defines": [
            "USE_ALBEDO_MAP"
          ],
          "options": [
            "v_uv",
            "v_uv1"
          ]
        },
        {
          "name": "USE_NORMAL_MAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "NORMAL_UV",
          "type": "string",
          "defines": [
            "USE_NORMAL_MAP"
          ],
          "options": [
            "v_uv",
            "v_uv1"
          ]
        },
        {
          "name": "DEFAULT_UV",
          "type": "string",
          "defines": [],
          "options": [
            "v_uv",
            "v_uv1"
          ]
        },
        {
          "name": "USE_PBR_MAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "USE_OCCLUSION_MAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "USE_EMISSIVE_MAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "EMISSIVE_UV",
          "type": "string",
          "defines": [
            "USE_EMISSIVE_MAP"
          ],
          "options": [
            "v_uv",
            "v_uv1"
          ]
        },
        {
          "name": "USE_ANISOTROPY_MAP",
          "type": "boolean",
          "defines": [
            "IS_ANISOTROPY"
          ]
        },
        {
          "name": "USE_ALPHA_TEST",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "ALPHA_TEST_CHANNEL",
          "type": "string",
          "defines": [
            "USE_ALPHA_TEST"
          ],
          "options": [
            "a",
            "r"
          ]
        },
        {
          "name": "FIX_ANISOTROPIC_ROTATION_MAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_SHADOW_TYPE",
          "type": "number",
          "defines": [
            "CC_RECEIVE_SHADOW",
            "CC_FORWARD_ADD",
            "!CC_ENABLE_CLUSTERED_LIGHT_CULLING"
          ],
          "range": [
            0,
            3
          ]
        },
        {
          "name": "CC_DIR_LIGHT_SHADOW_TYPE",
          "type": "number",
          "defines": [
            "!CC_FORWARD_ADD",
            "CC_ENABLE_CLUSTERED_LIGHT_CULLING",
            "CC_RECEIVE_SHADOW",
            "CC_SHADOW_TYPE"
          ],
          "range": [
            0,
            3
          ]
        }
      ],
      "name": "surfaces/standard|standard-vs|standard-fs"
    },
    {
      "blocks": [
        {
          "name": "Constants",
          "members": [
            {
              "name": "tilingOffset",
              "type": 16,
              "count": 1
            },
            {
              "name": "albedo",
              "type": 16,
              "count": 1
            },
            {
              "name": "albedoScaleAndCutoff",
              "type": 16,
              "count": 1
            },
            {
              "name": "pbrParams",
              "type": 16,
              "count": 1
            },
            {
              "name": "emissive",
              "type": 16,
              "count": 1
            },
            {
              "name": "emissiveScaleParam",
              "type": 16,
              "count": 1
            },
            {
              "name": "anisotropyParam",
              "type": 16,
              "count": 1
            }
          ],
          "defines": [],
          "stageFlags": 17,
          "binding": 0
        }
      ],
      "samplerTextures": [
        {
          "name": "albedoMap",
          "type": 28,
          "count": 1,
          "defines": [
            "USE_ALBEDO_MAP"
          ],
          "stageFlags": 16,
          "binding": 1
        },
        {
          "name": "normalMap",
          "type": 28,
          "count": 1,
          "defines": [
            "USE_NORMAL_MAP"
          ],
          "stageFlags": 16,
          "binding": 2
        },
        {
          "name": "pbrMap",
          "type": 28,
          "count": 1,
          "defines": [
            "USE_PBR_MAP"
          ],
          "stageFlags": 16,
          "binding": 3
        },
        {
          "name": "occlusionMap",
          "type": 28,
          "count": 1,
          "defines": [
            "USE_OCCLUSION_MAP"
          ],
          "stageFlags": 16,
          "binding": 4
        },
        {
          "name": "emissiveMap",
          "type": 28,
          "count": 1,
          "defines": [
            "USE_EMISSIVE_MAP"
          ],
          "stageFlags": 16,
          "binding": 5
        },
        {
          "name": "anisotropyMap",
          "type": 28,
          "count": 1,
          "defines": [
            "IS_ANISOTROPY",
            "USE_ANISOTROPY_MAP"
          ],
          "stageFlags": 16,
          "binding": 6
        },
        {
          "name": "anisotropyMapNearestFilter",
          "type": 28,
          "count": 1,
          "defines": [
            "IS_ANISOTROPY",
            "USE_ANISOTROPY_MAP"
          ],
          "stageFlags": 16,
          "binding": 7
        }
      ],
      "samplers": [],
      "textures": [],
      "buffers": [],
      "images": [],
      "subpassInputs": [],
      "attributes": [
        {
          "name": "a_position",
          "defines": [],
          "format": 32,
          "location": 0
        },
        {
          "name": "a_normal",
          "defines": [],
          "format": 32,
          "location": 1
        },
        {
          "name": "a_texCoord",
          "defines": [],
          "format": 21,
          "location": 2
        },
        {
          "name": "a_tangent",
          "defines": [],
          "format": 44,
          "location": 3
        },
        {
          "name": "a_color",
          "defines": [
            "CC_SURFACES_USE_VERTEX_COLOR"
          ],
          "format": 44,
          "location": 6
        },
        {
          "name": "a_texCoord1",
          "defines": [],
          "format": 21,
          "location": 7
        },
        {
          "name": "a_joints",
          "defines": [
            "CC_USE_SKINNING"
          ],
          "location": 4
        },
        {
          "name": "a_weights",
          "defines": [
            "CC_USE_SKINNING"
          ],
          "format": 44,
          "location": 5
        },
        {
          "name": "a_jointAnimInfo",
          "defines": [
            "USE_INSTANCING",
            "CC_USE_BAKED_ANIMATION"
          ],
          "format": 44,
          "isInstanced": true,
          "location": 8
        },
        {
          "name": "a_matWorld0",
          "defines": [
            "USE_INSTANCING"
          ],
          "format": 44,
          "isInstanced": true,
          "location": 9
        },
        {
          "name": "a_matWorld1",
          "defines": [
            "USE_INSTANCING"
          ],
          "format": 44,
          "isInstanced": true,
          "location": 10
        },
        {
          "name": "a_matWorld2",
          "defines": [
            "USE_INSTANCING"
          ],
          "format": 44,
          "isInstanced": true,
          "location": 11
        },
        {
          "name": "a_lightingMapUVParam",
          "defines": [
            "USE_INSTANCING",
            "CC_USE_LIGHTMAP"
          ],
          "format": 44,
          "isInstanced": true,
          "location": 12
        },
        {
          "name": "a_localShadowBias",
          "defines": [
            "USE_INSTANCING",
            "CC_RECEIVE_SHADOW"
          ],
          "format": 21,
          "isInstanced": true,
          "location": 13
        },
        {
          "name": "a_dyn_batch_id",
          "defines": [
            "!USE_INSTANCING",
            "USE_BATCHING"
          ],
          "format": 11,
          "location": 14
        },
        {
          "name": "a_vertexId",
          "defines": [
            "CC_USE_MORPH"
          ],
          "format": 11,
          "location": 15
        }
      ],
      "varyings": [
        {
          "name": "v_worldPos",
          "type": 15,
          "count": 1,
          "defines": [],
          "stageFlags": 17,
          "location": 0
        },
        {
          "name": "v_normal",
          "type": 16,
          "count": 1,
          "defines": [],
          "stageFlags": 17,
          "location": 1
        },
        {
          "name": "v_uv",
          "type": 14,
          "count": 1,
          "defines": [],
          "stageFlags": 17,
          "location": 2
        },
        {
          "name": "v_color",
          "type": 16,
          "count": 1,
          "defines": [
            "CC_SURFACES_USE_VERTEX_COLOR"
          ],
          "stageFlags": 17,
          "location": 3
        },
        {
          "name": "v_tangent",
          "type": 16,
          "count": 1,
          "defines": [],
          "stageFlags": 17,
          "location": 4
        },
        {
          "name": "v_uv1",
          "type": 14,
          "count": 1,
          "defines": [
            "!CC_USE_LIGHTMAP"
          ],
          "stageFlags": 17,
          "location": 5
        },
        {
          "name": "v_luv",
          "type": 15,
          "count": 1,
          "defines": [
            "CC_USE_LIGHTMAP",
            "!USE_BATCHING",
            "!CC_FORWARD_ADD"
          ],
          "stageFlags": 17,
          "location": 6
        },
        {
          "name": "v_shadowBias",
          "type": 14,
          "count": 1,
          "defines": [
            "CC_RECEIVE_SHADOW"
          ],
          "stageFlags": 17,
          "location": 7
        },
        {
          "name": "v_fogFactor",
          "type": 13,
          "count": 1,
          "defines": [
            "CC_USE_FOG",
            "!CC_USE_ACCURATE_FOG"
          ],
          "stageFlags": 17,
          "location": 8
        },
        {
          "name": "v_localPos",
          "type": 16,
          "count": 1,
          "defines": [],
          "stageFlags": 17,
          "location": 9
        },
        {
          "name": "v_clip_depth",
          "type": 14,
          "count": 1,
          "defines": [],
          "stageFlags": 17,
          "location": 10
        }
      ],
      "fragColors": [
        {
          "name": "fragColorX",
          "typename": "vec4",
          "type": 16,
          "count": 1,
          "defines": [],
          "stageFlags": 16,
          "location": 0
        }
      ],
      "hash": 1944620119,
      "glsl4": {
        "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#if CC_USE_LIGHTMAP\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 1\n  #endif\n#else\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  layout(location = 3) in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  layout(location = 6) in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 7) in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 8) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 9) in vec4 a_matWorld0;\n  layout(location = 10) in vec4 a_matWorld1;\n  layout(location = 11) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 12) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 13) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 14) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n#endif\nlayout(location = 0) out highp vec3 v_worldPos;\nlayout(location = 1) out mediump vec4 v_normal;\nlayout(location = 2) out vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  layout(location = 3) out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  layout(location = 4) out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  layout(location = 5) out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 6) out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) out mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  layout(location = 8) out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  layout(location = 9) out highp vec4 v_localPos;\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW\n  vec2 shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      layout(set = 2, binding = 6) uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(set = 2, binding = 3) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1;\n#endif\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBias;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nlayout(location = 10) out highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}",
        "frag": "\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#if CC_USE_LIGHTMAP\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 1\n  #endif\n#else\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nlayout(location = 0) in highp vec3 v_worldPos;\nlayout(location = 1) in mediump vec4 v_normal;\nlayout(location = 2) in vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  layout(location = 3) in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  layout(location = 4) in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  layout(location = 5) in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 6) in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) in mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  layout(location = 8) in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  layout(location = 9) in highp vec4 v_localPos;\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (cc_debug_view_mode.y > 0.0)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (cc_debug_view_mode.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (cc_debug_view_composite_pack_1.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (cc_debug_view_composite_pack_1.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (cc_debug_view_composite_pack_1.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (cc_debug_view_composite_pack_1.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (cc_debug_view_composite_pack_2.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (cc_debug_view_composite_pack_2.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (cc_debug_view_composite_pack_2.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (cc_debug_view_composite_pack_2.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (cc_debug_view_composite_pack_3.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (cc_debug_view_composite_pack_3.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (cc_debug_view_composite_pack_3.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (cc_debug_view_composite_pack_3.w > 0.0)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(set = 2, binding = 1) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(set = 0, binding = 3) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 5) uniform samplerCube cc_environment;\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 7) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 4) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 6) uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 4) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 5) uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  layout(set = 1, binding = 6) uniform sampler2D anisotropyMap;\n  layout(set = 1, binding = 7) uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n  #if USE_ALPHA_TEST\n    float alpha = albedo.ALPHA_TEST_CHANNEL;\n    #if USE_VERTEX_COLOR\n      alpha *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha = texture(albedoMap, ALBEDO_UV).ALPHA_TEST_CHANNEL;\n    #endif\n    if (alpha < albedoScaleAndCutoff.w) discard;\n  #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nlayout(location = 10) in highp vec2 v_clip_depth;\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\n  SurfacesFragmentAlphaClipOnly();\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > EPSILON && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    fragColorX = packDepthToRGBA(clipDepth);\n  #else\n    fragColorX = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#if CC_USE_LIGHTMAP\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 1\n  #endif\n#else\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\nout highp vec3 v_worldPos;\nout mediump vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW\n  vec2 shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1;\n#endif\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBias;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nout highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}",
        "frag": "\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#if CC_USE_LIGHTMAP\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 1\n  #endif\n#else\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin highp vec3 v_worldPos;\nin mediump vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (cc_debug_view_mode.y > 0.0)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (cc_debug_view_mode.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (cc_debug_view_composite_pack_1.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (cc_debug_view_composite_pack_1.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (cc_debug_view_composite_pack_1.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (cc_debug_view_composite_pack_1.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (cc_debug_view_composite_pack_2.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (cc_debug_view_composite_pack_2.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (cc_debug_view_composite_pack_2.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (cc_debug_view_composite_pack_2.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (cc_debug_view_composite_pack_3.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (cc_debug_view_composite_pack_3.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (cc_debug_view_composite_pack_3.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (cc_debug_view_composite_pack_3.w > 0.0)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n  #if USE_ALPHA_TEST\n    float alpha = albedo.ALPHA_TEST_CHANNEL;\n    #if USE_VERTEX_COLOR\n      alpha *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha = texture(albedoMap, ALBEDO_UV).ALPHA_TEST_CHANNEL;\n    #endif\n    if (alpha < albedoScaleAndCutoff.w) discard;\n  #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nin highp vec2 v_clip_depth;\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\n  SurfacesFragmentAlphaClipOnly();\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > EPSILON && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    fragColorX = packDepthToRGBA(clipDepth);\n  #else\n    fragColorX = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#if CC_USE_LIGHTMAP\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 1\n  #endif\n#else\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW\n  vec2 shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matLightViewProj;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1;\n#endif\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBias;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvarying highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}",
        "frag": "\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#if CC_USE_LIGHTMAP\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 1\n  #endif\n#else\n  #ifndef CC_SURFACES_USE_LIGHT_MAP\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBias\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\nuniform mediump vec4 cc_debug_view_mode;\n  uniform mediump vec4 cc_debug_view_composite_pack_1;\n  uniform mediump vec4 cc_debug_view_composite_pack_2;\n  uniform mediump vec4 cc_debug_view_composite_pack_3;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (cc_debug_view_mode.y > 0.0)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (cc_debug_view_mode.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (cc_debug_view_composite_pack_1.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (cc_debug_view_composite_pack_1.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (cc_debug_view_composite_pack_1.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (cc_debug_view_composite_pack_1.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (cc_debug_view_composite_pack_2.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (cc_debug_view_composite_pack_2.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (cc_debug_view_composite_pack_2.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (cc_debug_view_composite_pack_2.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (cc_debug_view_composite_pack_3.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (cc_debug_view_composite_pack_3.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (cc_debug_view_composite_pack_3.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (cc_debug_view_composite_pack_3.w > 0.0)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    #endif\n  #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\n    uniform vec4 albedo;\n    uniform vec4 albedoScaleAndCutoff;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n  #if USE_ALPHA_TEST\n    float alpha = albedo.ALPHA_TEST_CHANNEL;\n    #if USE_VERTEX_COLOR\n      alpha *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha = texture2D(albedoMap, ALBEDO_UV).ALPHA_TEST_CHANNEL;\n    #endif\n    if (alpha < albedoScaleAndCutoff.w) discard;\n  #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvarying highp vec2 v_clip_depth;\nvoid main () {\n  SurfacesFragmentAlphaClipOnly();\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > EPSILON && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    gl_FragColor = packDepthToRGBA(clipDepth);\n  #else\n    gl_FragColor = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"
      },
      "builtins": {
        "globals": {
          "blocks": [
            {
              "name": "CCGlobal",
              "defines": []
            },
            {
              "name": "CCCamera",
              "defines": []
            },
            {
              "name": "CCShadow",
              "defines": []
            },
            {
              "name": "CCCSM",
              "defines": [
                "CC_SUPPORT_CASCADED_SHADOW_MAP"
              ]
            }
          ],
          "samplerTextures": [
            {
              "name": "cc_environment",
              "defines": [
                "CC_USE_IBL"
              ]
            },
            {
              "name": "cc_diffuseMap",
              "defines": [
                "CC_USE_IBL",
                "CC_USE_DIFFUSEMAP"
              ]
            },
            {
              "name": "cc_shadowMap",
              "defines": [
                "CC_RECEIVE_SHADOW"
              ]
            },
            {
              "name": "cc_spotShadowMap",
              "defines": [
                "CC_RECEIVE_SHADOW"
              ]
            }
          ],
          "buffers": [],
          "images": []
        },
        "locals": {
          "blocks": [
            {
              "name": "CCLocalBatched",
              "defines": [
                "!USE_INSTANCING",
                "USE_BATCHING"
              ]
            },
            {
              "name": "CCLocal",
              "defines": [
                "!USE_INSTANCING",
                "!USE_BATCHING"
              ]
            },
            {
              "name": "CCMorph",
              "defines": [
                "CC_USE_MORPH"
              ]
            },
            {
              "name": "CCSkinningTexture",
              "defines": [
                "CC_USE_SKINNING",
                "CC_USE_BAKED_ANIMATION"
              ]
            },
            {
              "name": "CCSkinningAnimation",
              "defines": [
                "CC_USE_SKINNING",
                "CC_USE_BAKED_ANIMATION"
              ]
            },
            {
              "name": "CCSkinning",
              "defines": [
                "CC_USE_SKINNING",
                "!CC_USE_BAKED_ANIMATION",
                "!CC_USE_REAL_TIME_JOINT_TEXTURE"
              ]
            },
            {
              "name": "CCForwardLight",
              "defines": [
                "CC_FORWARD_ADD",
                "CC_ENABLE_CLUSTERED_LIGHT_CULLING"
              ]
            }
          ],
          "samplerTextures": [
            {
              "name": "cc_PositionDisplacements",
              "defines": [
                "CC_USE_MORPH",
                "CC_MORPH_TARGET_HAS_POSITION"
              ]
            },
            {
              "name": "cc_NormalDisplacements",
              "defines": [
                "CC_USE_MORPH",
                "CC_MORPH_TARGET_HAS_NORMAL"
              ]
            },
            {
              "name": "cc_TangentDisplacements",
              "defines": [
                "CC_USE_MORPH",
                "CC_MORPH_TARGET_HAS_TANGENT"
              ]
            },
            {
              "name": "cc_jointTexture",
              "defines": [
                "CC_USE_SKINNING",
                "CC_USE_BAKED_ANIMATION"
              ]
            },
            {
              "name": "cc_realtimeJoint",
              "defines": [
                "CC_USE_SKINNING",
                "!CC_USE_BAKED_ANIMATION",
                "CC_USE_REAL_TIME_JOINT_TEXTURE"
              ]
            },
            {
              "name": "cc_lightingMap",
              "defines": [
                "CC_USE_LIGHTMAP",
                "!USE_BATCHING",
                "!CC_FORWARD_ADD"
              ]
            }
          ],
          "buffers": [],
          "images": []
        },
        "statistics": {
          "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 135,
          "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 108
        }
      },
      "defines": [
        {
          "name": "USE_INSTANCING",
          "type": "boolean",
          "defines": [],
          "editor": {
            "elevated": true
          }
        },
        {
          "name": "USE_BATCHING",
          "type": "boolean",
          "defines": [
            "!USE_INSTANCING"
          ],
          "editor": {
            "elevated": true
          }
        },
        {
          "name": "CC_USE_LIGHTMAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_SKINNING",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_BAKED_ANIMATION",
          "type": "boolean",
          "defines": [
            "USE_INSTANCING"
          ]
        },
        {
          "name": "CC_RECEIVE_SHADOW",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_MORPH",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_FORWARD_ADD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_FOG",
          "type": "number",
          "defines": [],
          "range": [
            0,
            4
          ]
        },
        {
          "name": "CC_USE_ACCURATE_FOG",
          "type": "boolean",
          "defines": [
            "CC_USE_FOG"
          ]
        },
        {
          "name": "CC_MORPH_TARGET_COUNT",
          "type": "number",
          "defines": [
            "CC_USE_MORPH"
          ],
          "range": [
            2,
            8
          ]
        },
        {
          "name": "CC_MORPH_TARGET_HAS_POSITION",
          "type": "boolean",
          "defines": [
            "CC_USE_MORPH"
          ]
        },
        {
          "name": "CC_MORPH_TARGET_HAS_NORMAL",
          "type": "boolean",
          "defines": [
            "CC_USE_MORPH"
          ]
        },
        {
          "name": "CC_MORPH_TARGET_HAS_TANGENT",
          "type": "boolean",
          "defines": [
            "CC_USE_MORPH"
          ]
        },
        {
          "name": "CC_MORPH_PRECOMPUTED",
          "type": "boolean",
          "defines": [
            "CC_USE_MORPH"
          ]
        },
        {
          "name": "CC_USE_REAL_TIME_JOINT_TEXTURE",
          "type": "boolean",
          "defines": [
            "CC_USE_SKINNING",
            "!CC_USE_BAKED_ANIMATION"
          ]
        },
        {
          "name": "CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER",
          "type": "number",
          "defines": [],
          "range": [
            0,
            1
          ]
        },
        {
          "name": "CC_PIPELINE_TYPE",
          "type": "number",
          "defines": [],
          "range": [
            0,
            1
          ]
        },
        {
          "name": "CC_FORCE_FORWARD_SHADING",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_SUPPORT_CASCADED_SHADOW_MAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_IBL",
          "type": "number",
          "defines": [],
          "range": [
            0,
            2
          ]
        },
        {
          "name": "CC_USE_DIFFUSEMAP",
          "type": "number",
          "defines": [
            "CC_USE_IBL"
          ],
          "range": [
            0,
            2
          ]
        },
        {
          "name": "USE_ALBEDO_MAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "ALBEDO_UV",
          "type": "string",
          "defines": [
            "USE_ALBEDO_MAP"
          ],
          "options": [
            "v_uv",
            "v_uv1"
          ]
        },
        {
          "name": "USE_NORMAL_MAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "NORMAL_UV",
          "type": "string",
          "defines": [
            "USE_NORMAL_MAP"
          ],
          "options": [
            "v_uv",
            "v_uv1"
          ]
        },
        {
          "name": "DEFAULT_UV",
          "type": "string",
          "defines": [],
          "options": [
            "v_uv",
            "v_uv1"
          ]
        },
        {
          "name": "USE_PBR_MAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "USE_OCCLUSION_MAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "USE_EMISSIVE_MAP",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "EMISSIVE_UV",
          "type": "string",
          "defines": [
            "USE_EMISSIVE_MAP"
          ],
          "options": [
            "v_uv",
            "v_uv1"
          ]
        },
        {
          "name": "IS_ANISOTROPY",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "USE_ANISOTROPY_MAP",
          "type": "boolean",
          "defines": [
            "IS_ANISOTROPY"
          ]
        },
        {
          "name": "USE_ALPHA_TEST",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "ALPHA_TEST_CHANNEL",
          "type": "string",
          "defines": [
            "USE_ALPHA_TEST"
          ],
          "options": [
            "a",
            "r"
          ]
        },
        {
          "name": "USE_VERTEX_COLOR",
          "type": "boolean",
          "defines": [
            "USE_ALPHA_TEST"
          ]
        },
        {
          "name": "CC_SHADOWMAP_USE_LINEAR_DEPTH",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_SHADOWMAP_FORMAT",
          "type": "number",
          "defines": [],
          "range": [
            0,
            3
          ]
        }
      ],
      "name": "surfaces/standard|shadow-caster-vs|shadow-caster-fs"
    }
  ],
  "combinations": [
    {},
    {}
  ],
  "hideInEditor": false
}